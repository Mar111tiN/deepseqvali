import pandas as pd
import os
import re


def get_files(config):
    '''
    retrieves the path to all the files in the sample_sheet
    if rerun == False, it looks for fastq files
    if rerun == True, it looks for bam files
    outputs the necessary dataframes in a df dictionary for easy access
    '''

    demulti=config['setup']['demulti']

    # folder_list
    folder_list = config['inputdirs']
    # check whether single folder or folder list
    if (len(folder_list[0]) == 1): # that means 
        folder_list = [folder_list]
    

    # get the mutation file
    mut_sheet = config['samples']['mutation_sheet']
    # check full path or append path to scriptdir
    if not mut_sheet.startswith('/'):
        mut_sheet = os.path.join(snakedir, mut_sheet)

    # import the mutation sheet (with file extension check)
    if os.path.splitext(mut_sheet)[1] == ".xlsx":
        show_output(
            f"Reading excel mutation list {mut_sheet}"
        )
        mut_df = pd.read_excel(mut_sheet)
    else:
        show_output(
            f"Reading csv mutation list {mut_sheet}"
        )
        mut_df = pd.read_csv(mut_sheet, sep='\t')


    # if demulti is true, sample_df is taken from the sample_sheet and the fastq_paths are inferred from list
    if demulti:
        # sample_sheet
        sample_sheet = config['samples']['sample_sheet']
        # check full path or append path to scriptdir
        if not sample_sheet.startswith('/'):
            sample_sheet = os.path.join(snakedir, sample_sheet)
        show_output(
            f"Reading sample sheet {sample_sheet}"
        )
        index_df = sheet2df(sample_sheet)
        fastq_df = index_df.copy()
        fastq_df['R1'] = "fastq/" + fastq_df['sample'] + ".1.fastq.gz"
        fastq_df['R2'] = "fastq/" + fastq_df['sample'] + ".2.fastq.gz"
        # apply the fastq paths known to be in the fastq folder
        fastq_df = fastq_df.set_index("sample").loc[:, ['R1', 'R2']]
        df_dict = dict(
            fastq=fastq_df,
            short_fastq=fastq_df,   # here all fastqs are short
            samples=index_df,
            muts=mut_df
        )

        if config['setup']['check_all_indices']:
            # get the permutated index files
            index_file = config['samples']['index_file']
            if not index_file.startswith('/'):
                index_file = os.path.join(snakedir, index_file)
            all_indices_df = index_permutator(index_file)
            df_dict['index'] = all_indices_df
        return df_dict


    #### GO on for no demulti

    # get the samples from the mutation df
    samples = mut_df.groupby('sample').first().iloc[:,:1]
    # for fastq files:
    fastq_list = []
    short_list = []
    # cycle through the input folders and look for matching fastq files
    for input_folder in folder_list:
        for folder, _, files in os.walk(input_folder):
            for file in files:
                if '.fastq.' in file and '.md5' not in file and 'trim' not in file and 'sub' not in file:
                    fastq_list.append(os.path.join(folder, file))
                    short_list.append(file)

    def get_fastq_paths(row, fastq_list=None):
        '''
        go through the sample list and find the respective read and index fastqs in the respective fastq_list
        '''

        # get the nomenclature for the fastq files from config
        read1 = 'R1'
        read2 = 'R2'
        index = config['samples']['umi_barcode'] if config['samples']['umi_barcode'] else None

        for file in fastq_list:
            # get the basename
            base_file = os.path.basename(file)
            if  base_file.startswith(f"{row.name}_"):
                if index:
                    if f'_{index}' in base_file:
                        row['index'] = file
                elif f'_{read1}_' in base_file:
                    row['R1'] = file
                elif f'_{read2}_' in base_file:
                    row['R2'] = file
        cols = ['R1', 'R2']
        if config['samples']['umi_barcode']:
            cols.append(onfig['samples']['umi_barcode'])
        return row.reindex(cols)

    fastq_df = samples.apply(get_fastq_paths, axis=1, fastq_list=fastq_list)
    short_df = samples.apply(get_fastq_paths, axis=1, fastq_list=short_list)

    # ########## DEBUG #################
    # print(short_df)
    # print(fastq_df)
    # ##################################
    df_dict = dict(
        fastq=fastq_df,
        short_fastq=short_df,
        muts=mut_df
    )
    return df_dict


def get_fastq(w):
    '''
    returns fastq path from wildcards sample and read
    '''

    return sample_df.loc[w.sample, w.read]


# ###################### FASTQC ###########################
def get_fastqc_list(_):
    '''
    returns the complete list of required fastqc files depending on trim option
    '''
    if config['setup']['demulti']:
        reads = [".1.",".2."] if config['setup']['PE'] else [".1."]
    else:
        reads = ['R1', 'R2'] if config['setup']['PE'] else ['R1']
    
    fastqc_list = [f"fastqc/{s}_{r}_fastqc.zip" for s in global_dfs['short_fastq'].index for r in reads]
    return fastqc_list


# ###################### ubamXT #########################################
def get_FastqToSam_input(w):
    '''
    retrieve either ...fastq or fastq.trim pairs depending on config:trim:trimming value for bwa alignment
    '''

    reads = ['R1', 'R2']
    # add the index read, if UMIs are involved
    if config['setup']['UMI']:
        reads.append('index')

    return global_dfs['fastq'].loc[w.sample, reads]


# ############## INDEL REALIGNER ######################
def get_IR_input(w):
    '''
    complex sample switch depending on pipeline settings
    !!!! ELABORATE
    if UMIs are used, do not dedup before the UMI-filtering steps (if active)
    if UMI-filter is inactive, just dedup using umis
    if no UMIs are used, just mark_dups before realigning
    '''

    if config['setup']['UMI']:
        if config['UMI_filter']['run']:
            bam = f"mapped/{w.sample}.bam"
        else:
            bam = f"umi_deduped/{w.sample}.bam"
    else:
        bam = f"deduped/{w.sample}.bam"
    return {'bam': bam}

###### GENERAL UTILITY ##################################
def full_path(file):

    '''
    returns the full path to a reference
    '''

    build = config['ref']['build']
    full_ref_path = os.path.join(config['paths']['mystatic'], config['ref'][build][file])
    return full_ref_path


################### LEGACY ######################################

# def full_path(file):

#     '''
#     returns the full path to a reference
#     '''

#     build = config['ref']['build']
#     full_ref_path = os.path.join(config['paths']['mystatic'], config['ref'][build][file])
#     return full_ref_path


# def static_path(file):
#     '''
#     returns the absolute path when given relative to static folder
#     '''

#     return os.path.join(config['paths']['mystatic'], file)


# def get_fastq_origin(w):
#     '''
#     returns the path to the original fastq file
#     '''
#     path = os.path.join(config['inputdir'], "fastq")
#     return f"{path}/{w.sample}_{w.type}_R{w.read}.fastq"


# def get_fastq_link(w):
#     '''
#     returns the path to the fastq-symlink in the work directory
#     '''
#     return f"fastq/{w.sample}_{w.type}_R{w.read}.fastq"


# def get_fastq_pair(w):
#     return [f"fastq/{w.sample}_{w.type}_R{read}.fastq" for read in [1, 2]]
